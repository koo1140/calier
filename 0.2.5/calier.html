<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêôCalier - Editor</title>
    <meta name="description" content="A fully offline HTML code editor, with a lot of tools. AI Playground, auto code saving & more!">
    <link rel="icon" href="https://raw.githubusercontent.com/koo1140/calier/refs/heads/main/octopus.png" type="image/png">

    <!-- Open Graph Metadata for Rich Previews -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Calier - Editor">
    <meta property="og:description" content="A fully offline HTML code editor, with a lot of tools. AI Playground, auto code saving & more!">
    <meta property="og:image" content="https://raw.githubusercontent.com/koo1140/calier/refs/heads/main/octopus.png">
    <!--<meta property="og:url" content="https://example.com">-->

    <!-- Twitter Card Metadata -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Calier - Editor">
    <meta name="twitter:description" content="A fully offline HTML code editor, with a lot of tools. AI Playground, auto code saving & more!">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/koo1140/calier/refs/heads/main/octopus.png">

    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #121212;
            color: #e0e0e0;
        }
        
        /* Apply dark theme to all scrollbars */
* {
    scrollbar-width: thin; /* For Firefox */
    scrollbar-color: #2b2b2b #1a1a1a; /* thumb color and track color */
}

/* For WebKit-based browsers (Chrome, Edge, Safari) */ 
*::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

*::-webkit-scrollbar-thumb {
    background-color: #2b2b2b;
    border-radius: 6px;
    border: 2px solid #1a1a1a;
}

*::-webkit-scrollbar-track {
    background-color: #1a1a1a;
    border-radius: 6px;
}


       .sidebar {
    width: 50px; /* Start closed */
    background-color: #1e1e1e;
    padding: 15px 5px; /* Minimized padding */
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
    overflow: hidden;
    align-items: center;
    position: relative;
    transition: width 0.5s ease, padding 0.5s ease; /* Smooth open/close */
}

.sidebar:hover {
    width: 200px; /* Expanded width */
    padding: 15px; /* Expanded padding */
}


        
        .sidebar a {
    position: absolute;
    bottom: 40px; /* Adjust spacing from the bottom */
    left: 50%;
    transform: translateX(-50%); /* Center horizontally */
    font-size: 0.7em;
    color: #e0e0e0;
    background-color: #1e1e1e;
    padding: 10px 20px;
    text-decoration: none; /* Remove underline */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease, transform 0.3s ease;
    border-radius: 25px;
}

.sidebar a:hover {
    background-color: #333;
    transform: scale(1.1);
    transform: translateX(-50%);
}


        .sidebar .title {
    font-size: 2.0em;
    color: #e0e0e0;
    margin-bottom: 15px;
    text-align: center;
    max-height: 0;
    overflow: hidden;
    position: relative;
    transition: max-height 0.1s ease-out;
}

.sidebar::before {
    content: "üêô";
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 10px; /* Adjust to align with the title's position */
    font-size: 2.0em;
    color: #e0e0e0;
    opacity: 1;
    transition: opacity 0.5s ease-out;
}

.sidebar:hover .title {
    max-height: 100px;
    transition: max-height 0.24s ease-in;
}

.sidebar:hover::before {
    opacity: 0;
    transition: opacity 0.1s ease-in;
}

        .sidebar button {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #333;
            color: #e0e0e0;
            border: none;
            padding: 10px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            transform: scale(1);
            width: 100%;
            gap: 10px;
        }

        .sidebar button span {
            display: inline-block;
            transition: opacity 0.3s ease;
            opacity: 0;
            white-space: nowrap;
            overflow: hidden;
        }

        .sidebar:hover button span {
            opacity: 1;
        }

        .sidebar:hover button {
            justify-content: flex-start;
        }

        .sidebar button:hover {
            background-color: #555;
            transform: scale(1.1);
        }

        .editor-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor, .preview {
            flex: 1;
            height: 100%;
            padding: 0;
            margin: 0;
            border: none;
        }

        .editor {
            border-right: 2px solid #333;
        }

        iframe {
            border: none;
            background-color: #202020;
        }

        .hidden {
            display: none;
        }

        .version {
            margin-top: auto;
            font-size: 1.2em;
            text-align: center;
            color: #888; /* Gray tone */
        }

        /* Popup Styles */
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            padding: 20px;
            border-radius: 8px;
            display: none;
            width: 80%;
            max-width: 600px;
            z-index: 1000;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.5);
        }

        .popup .popup-header {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #e0e0e0;
        }

        .popup .popup-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .popup button {
            background-color: #444;
            color: #e0e0e0;
            border: none;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
        }

        .popup button:hover {
            background-color: #555;
        }

        .extension-item {
            background-color: #2d2d2d;
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .extension-item button {
            background-color: #333;
            color: #e0e0e0;
        }

        .extension-item button:hover {
            background-color: #555;
        }

        .fetch-btn {
            margin-left: 10px;
            background-color: #444;
            color: #e0e0e0;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
        }

        .fetch-btn:hover {
            background-color: #555;
        }
    </style>
    <style>
    /* Full dark theme */
    #ai-playground-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 10, 10, 0.95); /* Darker overlay */
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    #ai-playground-content {
        background: #1e1e1e; /* Dark content background */
        color: #ffffff; /* White text for contrast */
        padding: 20px;
        border-radius: 15px; /* Rounded borders */
        width: 80%;
        max-width: 600px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3); /* Slightly heavier shadow */
        position: relative;
    }

    #ai-playground-content h2 {
        margin-top: 0;
        color: #ffcf33; /* Accent color for headings */
    }

    #ai-playground-content button {
        margin-top: 10px;
        padding: 10px 16px;
        cursor: pointer;
        border: none;
        border-radius: 10px; /* Rounded buttons */
        color: #fff;
        background: #555555; /* Subtle button background */
        transition: background-color 0.3s ease;
    }

    #ai-playground-content button:hover {
        background: #ffcf33; /* Accent color on hover */
        color: #000;
        transform: scale(1.1);
    }

    #close-ai-playground {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #ff4b5c; /* Bright close button */
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 50%; /* Circular close button */
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    #ai-playground-input {
        width: 93%;
        padding: 3%;
        margin: 10px 0;
        border: 1px solid #444444; /* Subtle border */
        border-radius: 20px; /* Rounded input field */
        background: #2e2e2e; /* Dark input background */
        color: #ffffff; /* Input text color */
        font-size: 20px;
    }

    #ai-playground-input::placeholder {
        color: #aaaaaa; /* Placeholder text color */
    }

    #ai-playground-input:focus {
        border-color: #ffcf33; /* Highlighted border on focus */
        outline: none;
        box-shadow: 0 0 5px #ffcf33; /* Glow effect on focus */
    }
    /* Style the container */
/* Style the container */
.checkbox-container {
    position: relative;
    display: inline-block;
    font-size: 18px;
    padding-left: 30px; /* Space for the checkbox */
    cursor: pointer;
}

/* Hide the default checkbox */
.checkbox-container input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

/* Style the custom checkmark */
.checkbox-container .checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 20px;
    width: 20px;
    border: 2px solid #ccc;
    background-color: #fff;
    border-radius: 4px;
}

/* When the checkbox is checked */
.checkbox-container input:checked ~ .checkmark {
    background-color: #4CAF50; /* Green background */
    border-color: #4CAF50; /* Green border */
}

/* Checkmark inside the box when checked */
.checkbox-container input:checked ~ .checkmark:after {
    content: "";
    position: absolute;
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg);
}

/* Hover effect */
.checkbox-container:hover .checkmark {
    border-color: #999;
}

/* Tooltip text styling */
.tooltip-text {
    visibility: hidden;
    position: absolute;
    top: 30px;
    left: 0;
    background-color: #333;
    color: #fff;
    text-align: center;
    border-radius: 4px;
    padding: 5px;
    font-size: 14px;
    width: 220px;
    z-index: 1;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none; /* Prevents tooltip from interfering with clicks */
}

/* Show the tooltip when hovering over the label */
.checkbox-container:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}


</style>


<style>
/* Floating div containing editor selection details */
#floating-div {
    display: none;
    position: absolute;
    background-color: #1e1e1e; /* Slightly lighter dark background */
    color: #ffffff;
    padding: 20px;
    border-radius: 8px;  /* Smooth rounded corners */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.7);  /* Stronger shadow */
    max-width: 400px;
    z-index: 9999;
    transition: all 0.3s ease;  /* Smooth transitions for floating div */
}

/* Close button styling */
#close-btn {
    cursor: pointer;
    font-weight: bold;
    font-size: 18px;
    color: #ff4d4d;  /* Slightly softer red for the close button */
    float: right;
    transition: color 0.3s ease;
}

#close-btn:hover {
    color: #ff0000;  /* Bright red on hover */
}

/* Input bar for editing */
#input-bar {
    max-width: 95%;
    width: 100%;
    height: 50px;
    background-color: #1e1e1e; 
    color: #ffffff;
    border: 1px solid #444; 
    border-radius: 5px;
    padding: 12px;
    font-size: 16px;
    margin: 0 auto;
    margin-top: 10px;
    resize: none;
    transition: border-color 0.3s ease;
}

#input-bar:focus {
    border-color: #ff4d4d;  /* Red border when focused */
}

/* Edit with AI button */
#edit-ai-btn {
    background-color: #333333;  /* Dark background */
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 5px;
    font-size: 16px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    transition: background-color 0.3s ease;
}

#edit-ai-btn:hover {
    background-color: #555555;  /* Lighten on hover */
}

/* Label for AI result */
#ai-result {
    color: #ffffff;
    display: none;
    font-size: 16px;
    margin-top: 20px;
}

/* AI result output */
#ai-result-text {
    background-color: #222222;  /* Dark background for AI output */
    color: #ffffff;
    padding: 12px;
    border-radius: 5px;
    font-size: 14px;
    white-space: pre-wrap;
    word-wrap: break-word;
    margin-top: 10px;
    transition: background-color 0.3s ease;
}

#ai-result-text:hover {
    background-color: #333333;  /* Slight hover effect */
}

/* Replace button for replacing text with AI output */
#replace-btn {
    background-color: #28a745;  /* Green button */
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 5px;
    font-size: 16px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    display: none;
    transition: background-color 0.3s ease;
}

#replace-btn:hover {
    background-color: #218838;  /* Darker green on hover */
}

/* Button and result hover effects */
button:hover, #ai-result-text:hover {
    opacity: 0.9;
}

/* Smooth transition for all interactive elements */
input, button, #floating-div {
    transition: all 0.3s ease;
}
</style>
<style>
        /* Hidden state */
        .hidden {
            opacity: 0;
        }

        /* Fully visible state with fade-in effect */
        .visible {
            opacity: 1;
            transition: opacity 0.5s ease-in-out; /* Fade-in effect */
        }
    </style>
<style>
  #floating-div {
    user-select: none; /* Prevent text selection for the whole div */
  }

  #input-bar {
    user-select: text; /* Allow text selection only in the textarea */
  }
</style>



</head>
<body>
    <div class="sidebar">
    <!-- Title -->
    <div id='title' class="title">üêôCalier</div>

    <!-- High-Priority Action -->
    <button id="run-code">
        ‚ñ∂Ô∏è <span>Run</span>
    </button>
    
        <!-- External Navigation -->
    <button id="new-tab">
        üåê <span>Open in New Tab</span>
    </button>
    <button id="new-window">
        ü™ü <span>Open in New Window</span>
    </button>

    <!-- Editor and Preview Toggles -->
    <button id="toggle-editor">
        üñäÔ∏è <span>Toggle Editor</span>
    </button>
    <button id="toggle-preview">
        üëÄ <span>Toggle Preview</span>
    </button>
    <button id="toggle-bg">
        üé® <span>Toggle Background</span>
    </button>
    
    <!-- Misc -->
<button id="clear-file-btn">
    üßπ <span>Clear Code</span>
</button>
<button id="copy-code-btn">
    üìã <span>Copy Code</span>
</button>
<button id="replace-code-btn">
    üîÑ <span>Replace Code</span>
</button>

<!-- AI Playground Button -->
    <button id="open-ai-playground">
        ü§ñ <span>AI Playground</span>
    </button>

    <!-- Extensions -->
    <button id="extensions-btn">
        üîå <span>Extensions</span>
    </button>
    
        <!-- External Link -->
    <a id="exlink" href="https://github.com/koo1140/calier" target="_blank" style="text-decoration: none; text-align: center; margin-top: 10px;">
        üêô <span>GitHub</span>
    </a>

    <!-- Version -->
    <div id='version' class="version">v0.2.5</div>
</div>


<div id="floating-div" >
    <span id="close-btn" >‚úñ</span>
    <span id="info-text">Selected Text</span>

    <!-- Input for editing the selected text -->
    <div>
        <textarea id="input-bar" ></textarea>
    </div>

    <!-- Button to trigger AI text editing -->
    <button id="edit-ai-btn">‚ú® Magic</button>

    <!-- Area to show AI result -->
    <div>
        <span id="ai-result">Response:</span>
        <pre id="ai-result-text"></pre>
    </div>

    <!-- Replace Button -->
    <button id="replace-btn" >Replace with AI Output</button>
</div>
<script>
  document.getElementById('floating-div').addEventListener('mousedown', function(e) {
    var div = this;
    var offsetX = e.clientX - div.getBoundingClientRect().left;
    var offsetY = e.clientY - div.getBoundingClientRect().top;
    var isDragging = false;

    function onMouseMove(e) {
      if (!isDragging) {
        isDragging = true;
        // Start animation frame to smoothen movement
        requestAnimationFrame(function updatePosition() {
          div.style.left = (e.clientX - offsetX) + 'px';
          div.style.top = (e.clientY - offsetY) + 'px';
        });
      } else {
        // Keep updating position during drag
        requestAnimationFrame(function updatePosition() {
          div.style.left = (e.clientX - offsetX) + 'px';
          div.style.top = (e.clientY - offsetY) + 'px';
        });
      }
    }

    function onMouseUp() {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    }

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  });

  // Ensure the div starts in an absolute position
  document.getElementById('floating-div').style.position = 'absolute';
</script>




    <div id='editor-container' class="editor-container">
        <div id="editor" class="editor"></div>
        <iframe id="preview" class="preview"></iframe>
    </div>

    <!-- Extensions Popup -->
    <div id="extensions-popup" class="popup">
        <div class="popup-header">Manage Extensions</div>
        <div id="extensions-list" class="popup-content"></div>
        <button id="close-popup">Close</button>
        <button id="fetch-extensions" class="fetch-btn">Fetch Extensions</button>
    </div>


<!-- AI Playground Popup -->
<div id="ai-playground-popup" style="display: none;">
    <div id="ai-playground-content">
        <button id="close-ai-playground">Close</button>
        <h2>AI Playground - Powered by Zynx AI</h2>
        <input type="text" id="ai-playground-input" placeholder="What do you want to create today?" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
<button id="ai-playground-submit" style="display: inline-block; margin-right: 10px;">Submit</button>
<label class="checkbox-container" style="display: inline-block; margin-right: 10px;">
    Generate full code
    <input type="checkbox" id="generate-full-code">
    <span class="checkmark"></span>
    <span class="tooltip-text">When checked, AI will generate a full HTML file with CSS, HTML, and JavaScript. Otherwise, returns an element.</span>
</label>
<button id="copy-code-button" style="display: inline-block;">Copy Code</button>

        <div id="ai-playground-editor" style="height: 300px; width: 100%;"></div>
    </div>
</div>



<script>
    // List of IDs to animate
    const elementIds = [
        'editor-container',
        "run-code",
        "new-tab",
        "new-window",
        "toggle-editor",
        "toggle-preview",
        "toggle-bg",
        "clear-file-btn",
        "copy-code-btn",
        "replace-code-btn",
        "open-ai-playground",
        "extensions-btn",
        "exlink",
        "version"
    ];

    // Function to instantly hide elements with animation-ready styles
    function prepareElements(ids) {
        ids.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.opacity = "0"; // Start hidden
                element.style.transition = "opacity 0.5s ease-in-out"; // Set transition for fade-in
            } else {
                console.warn(`Element with ID "${id}" not found.`);
            }
        });
    }

    // Function to fade in elements one by one
    function fadeInElements(ids) {
        ids.forEach((id, index) => {
            const element = document.getElementById(id);
            if (element) {
                setTimeout(() => {
                    element.style.opacity = "1"; // Trigger fade-in
                }, index * 100); // Adjust delay between elements (100ms per element)
            }
        });
    }

    // On page load, prepare elements and then animate them
    window.addEventListener("DOMContentLoaded", () => {
        prepareElements(elementIds);
        fadeInElements(elementIds);
    });
</script>

    
    

    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.31.1/src-min-noconflict/ace.min.js"></script>
    <script>
    // Function to fetch AI response (mocked with fetch)
    async function FfetchAIResponse(prompt) {
        const SsystemPrompt = 'You are a HTML/CSS/JS code snippet generator & editor & summarizer but you also can explain what the code does. Only generate (or explain) the HTML/CSS/JS code element / mini snippet based on the instruction and selected code. Do not generate anything else than HTML/CSS/JS code, unless instructed or mentioned to explain. Only return generated/explained code without code blocks. You will receive a selected code, if asked, explain what the selected code does or edit it further, if code is empty, you may have to create new code. In summary, if user says \'explain\' you will explain the selected code. You accept html, css and javascript. When explaining, you explain what the code does, eg makes the website have dark colours. When explaining, do it very short and dont use highlightings. Do not talk to explain anything unless instructed. Only respond with direct working code that can we ue replace button to replace code with your generated code.';
           
        const SmaxTokens = 3000;
        
        const SpostData = {
            model: 'llama3.1-70b',
            messages: [
                {
                    role: 'system',
                    content: SsystemPrompt
                },
                {
                    role: 'user',
                    content: prompt,
                }
            ],
            max_tokens: SmaxTokens,
            temperature: 0.7
        };

        const apiKey = "zynx_test"; // API key for the mock API request

        try {
            const SapiResponse = await fetch('https://zynx.milosantos.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(SpostData)
            });

            const SresponseData = await SapiResponse.json();
            return SresponseData?.choices?.[0]?.message?.content || "No response from AI.";
        } catch (error) {
            console.error('Error fetching AI response:', error);
            return "An error occurred while fetching the response.";
        }
    }

    const Eeditor = ace.edit("editor");  // Assuming ACE editor is already initialized

    const floatingDiv = document.getElementById("floating-div");
    const closeBtn = document.getElementById("close-btn");
    const infoText = document.getElementById("info-text");
    const inputBar = document.getElementById("input-bar");
    const editAiBtn = document.getElementById("edit-ai-btn");
    const aiResultText = document.getElementById("ai-result-text");
    const aiResultLabel = document.getElementById("ai-result");
    const replaceBtn = document.getElementById("replace-btn");
    let mouseX = 0;
    let mouseY = 0;

    // Update mouse position on movement
    document.addEventListener("mousemove", (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
    });

    function showFloatingDiv() {
        const selection = Eeditor.getSelection();
        const range = selection.getRange();
        const selectedText = Eeditor.session.getTextRange(range).trim(); // Get the actual text from the range

        if (selectedText) {
            // Display the selected text in the floating div
            infoText.textContent = selectedText;
            inputBar.value = ""; // Clear input bar to let the user type their own text

            // Position the floating div near the mouse cursor
            floatingDiv.style.left = `${mouseX + 10}px`; // Slightly offset to the right
            floatingDiv.style.top = `${mouseY + 10}px`; // Slightly offset downward
            floatingDiv.style.display = "block";
        } else {
            // Hide the floating div if no text is selected
            floatingDiv.style.display = "none";
        }
    }

    function hideAIResults() {
        aiResultText.style.display = "none";
        aiResultLabel.style.display = "none";
        replaceBtn.style.display = "none";
    }

    function hideFloatingDiv() {
        floatingDiv.style.display = "none";
        hideAIResults(); // Hide AI results if floating div is closed
    }

    // Listen for selection changes in ACE editor
    Eeditor.on("changeSelection", () => {
        setTimeout(showFloatingDiv, 10); // Delay to ensure accurate position after mousemove
        
        // Hide AI result and replace button if no text is selected
        if (!Eeditor.getSelection().toString().trim()) {
            hideAIResults(); // Hide AI elements when no selection is made
        }
    });

    // Close button hides the floating div and AI results
    closeBtn.addEventListener("click", hideFloatingDiv);

    // AI Text Editing - Replace this with actual AI logic
    editAiBtn.addEventListener("click", async () => {
        const selection = Eeditor.getSelection();
        const range = selection.getRange();
        const selectedText = Eeditor.session.getTextRange(range).trim(); // Get the actual text from the range
        let currentText = inputBar.value.trim();

        if (currentText) {
            // Await the AI response here
            const editedText = await FfetchAIResponse("Selected code: " + selectedText + " Instruction: " + currentText);

            // Display the AI result
            aiResultLabel.style.display = "block";
            aiResultText.style.display = "block";
            aiResultText.textContent = editedText;

            replaceBtn.style.display = "inline-block";
        } else {
            alert("Please type something to edit!");
        }
    });

    // Replace the selected text in the editor with the AI-generated text
    replaceBtn.addEventListener("click", () => {
        const selection = Eeditor.getSelection();
        const range = selection.getRange();
        const editedText = aiResultText.textContent;

        // Replace the selected text with AI-generated output
        Eeditor.session.replace(range, editedText);

        // Close the floating div and clear AI result
        hideFloatingDiv();
    });

    // Detect deselection and hide the AI result
    document.addEventListener("mouseup", () => {
        if (!Eeditor.getSelection().toString().trim()) {
            hideAIResults(); // Hide the AI result if no selection exists
        }
    });

    // Ensure that AI results are cleared when a new selection is made
    Eeditor.on("changeSelection", () => {
        if (Eeditor.getSelection().toString().trim()) {
            hideAIResults(); // Hide AI result when a new selection is made
        }
    });
</script>





    <script>
    
    // Button Elements
const clearFileBtn = document.getElementById('clear-file-btn');
const copyCodeBtn = document.getElementById('copy-code-btn');
const replaceCodeBtn = document.getElementById('replace-code-btn');

// Handle Clear File Button
clearFileBtn.addEventListener('click', () => {
    // Clear the editor content
    editor.setValue('', -1);
    // Optionally, you can also clear the localStorage if you want to erase the saved content
  //localStorage.removeItem(STORAGE_KEY);
});

// Handle Copy Code Button
copyCodeBtn.addEventListener('click', () => {
    const code = editor.getValue();
    // Create a temporary textarea element to copy the code to clipboard
    const textarea = document.createElement('textarea');
    textarea.value = code;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
  //  alert('Code copied to clipboard!');
});

// Handle Replace Code Button
replaceCodeBtn.addEventListener('click', async () => {
    try {
        // Get the text content from the clipboard
        const clipboardText = await navigator.clipboard.readText();

        // Replace the editor content with the clipboard content
        editor.setValue(clipboardText, 1);
    } catch (error) {
        console.error("Failed to read clipboard content:", error);
        alert("Failed to read clipboard content.");
    }
});


const editorDiv = document.getElementById('editor');
const previewFrame = document.getElementById('preview');
const toggleEditorBtn = document.getElementById('toggle-editor');
const togglePreviewBtn = document.getElementById('toggle-preview');
const toggleBgBtn = document.getElementById('toggle-bg');
const runCodeBtn = document.getElementById('run-code');
const newTabBtn = document.getElementById('new-tab');
const newWindowBtn = document.getElementById('new-window');
const extensionsBtn = document.getElementById('extensions-btn');
const extensionsPopup = document.getElementById('extensions-popup');
const closePopupBtn = document.getElementById('close-popup');
const fetchExtensionsBtn = document.getElementById('fetch-extensions');
const extensionsList = document.getElementById('extensions-list');

let extensions = JSON.parse(localStorage.getItem('extensions')) || [];

// Initialize Ace Editor
const editor = ace.edit(editorDiv);
editor.setTheme("ace/theme/monokai");
editor.session.setMode("ace/mode/html");

const STORAGE_KEY = "calier-editor-content";

// Load code from localStorage on page load
window.addEventListener('load', () => {
    const savedContent = localStorage.getItem(STORAGE_KEY);
    if (savedContent) {
        editor.setValue(savedContent, -1); // Set saved content to editor
    } else {
        editor.setValue(`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Preview</title>
    <style>
        body {
            background-color: #202020;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>`, 1);
    }
});

// Save code to localStorage on change
editor.session.on('change', () => {
    const currentContent = editor.getValue();
    localStorage.setItem(STORAGE_KEY, currentContent);
});

// Button Actions
toggleEditorBtn.addEventListener('click', () => {
    editorDiv.classList.toggle('hidden');
    adjustLayout();
});

togglePreviewBtn.addEventListener('click', () => {
    previewFrame.classList.toggle('hidden');
    adjustLayout();
});

toggleBgBtn.addEventListener('click', () => {
    const previewDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
    const bodyStyle = previewDoc.body.style;

    // Toggle colors
    if (bodyStyle.backgroundColor === "rgb(32, 32, 32)") {
        bodyStyle.backgroundColor = "#ffffff";
        bodyStyle.color = "#000000";
    } else {
        bodyStyle.backgroundColor = "#202020";
        bodyStyle.color = "#e0e0e0";
    }
});

runCodeBtn.addEventListener('click', () => {
    const html = editor.getValue();
    previewFrame.srcdoc = html;

    // Save content on run
    localStorage.setItem(STORAGE_KEY, html);

    // Run enabled extensions
    runEnabledExtensions();
});

newTabBtn.addEventListener('click', () => {
    const html = editor.getValue();
    const newTab = window.open();
    newTab.document.open();
    newTab.document.write(html);
    newTab.document.close();
});

newWindowBtn.addEventListener('click', () => {
    const html = editor.getValue();
    const newWindow = window.open("", "", "width=800,height=600");
    newWindow.document.open();
    newWindow.document.write(html);
    newWindow.document.close();
});

extensionsBtn.addEventListener('click', () => {
    extensionsPopup.style.display = 'block';
    loadExtensions();
});

closePopupBtn.addEventListener('click', () => {
    extensionsPopup.style.display = 'none';
});

fetchExtensionsBtn.addEventListener('click', async () => {
    await fetchExtensions();
});

// Load extensions from local storage
function loadExtensions() {
    extensionsList.innerHTML = ''; // Clear existing list
    extensions.forEach(extension => {
        const extensionDiv = document.createElement('div');
        extensionDiv.classList.add('extension-item');
        extensionDiv.innerHTML = ` 
            <span>${extension.name}</span>
            <button onclick="toggleExtension('${extension.name}')">
                ${extension.enabled ? 'Disable' : 'Enable'}
            </button>
        `;
        extensionsList.appendChild(extensionDiv);
    });
}

// Toggle extension enabled/disabled
function toggleExtension(extensionName) {
    const extension = extensions.find(ext => ext.name === extensionName);
    if (extension) {
        extension.enabled = !extension.enabled;
        localStorage.setItem('extensions', JSON.stringify(extensions));
        loadExtensions();
        alert(`${extension.enabled ? 'Enabled' : 'Disabled'} ${extensionName}`);
        location.reload();
    }
}

// Fetch extensions from GitHub API
async function fetchExtensions() {
    const response = await fetch('https://api.github.com/repos/koo1140/calier/contents/extensions');
    const data = await response.json();
    const files = data.filter(file => file.name.endsWith('.js'));

    // Remove existing extensions before adding new ones
    extensions = [];

    for (const file of files) {
        const existing = extensions.find(ext => ext.name === file.name);
        if (!existing) {
            // Fetch the content of each file and store it in localStorage
            const fileResponse = await fetch(file.download_url);
            const fileContent = await fileResponse.text();
            
            // Save the code in localStorage
            localStorage.setItem(file.name, fileContent);

            extensions.push({ name: file.name, enabled: false });
        }
    }

    localStorage.setItem('extensions', JSON.stringify(extensions));
    loadExtensions();
}

// Run enabled extensions
function runEnabledExtensions() {
    extensions.forEach(extension => {
        if (extension.enabled) {
            try {
                // Get the code for the extension from localStorage
                const extensionCode = localStorage.getItem(extension.name);

                if (extensionCode) {
                    // Use eval or new Function to execute the extension code
                    eval(extensionCode);
                } else {
                    console.error(`No code found for extension: ${extension.name}`);
                }
            } catch (e) {
                console.error(`Error running extension ${extension.name}:`, e);
            }
        }
    });
}

// Adjust layout on toggle
function adjustLayout() {
    const editorVisible = !editorDiv.classList.contains('hidden');
    const previewVisible = !previewFrame.classList.contains('hidden');

    if (editorVisible && previewVisible) {
        editorDiv.style.flex = "1";
        previewFrame.style.flex = "1";
    } else if (editorVisible) {
        editorDiv.style.flex = "2";
        previewFrame.style.flex = "0";
    } else if (previewVisible) {
        editorDiv.style.flex = "0";
        previewFrame.style.flex = "2";
    } else {
        editorDiv.style.flex = "0";
        previewFrame.style.flex = "0";
    }
}

// Initialize layout
adjustLayout();

// Load extensions when editor loads
window.addEventListener('load', () => {
    runEnabledExtensions();
});

// Load code from URL parameter
window.addEventListener('load', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const codeParam = urlParams.get('code');
    
    if (codeParam) {
        // Decode the code from the URL and set it to the editor
        const decodedCode = decodeURIComponent(codeParam);
        editor.setValue(decodedCode, -1);
    } else {
        // If no URL parameter is provided, load the default code
        const savedContent = localStorage.getItem(STORAGE_KEY);
        if (savedContent) {
            editor.setValue(savedContent, -1); // Set saved content to editor
        } else {
            editor.setValue(`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Preview</title>
    <style>
        body {
            background-color: #202020;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>`, 1);
        }
    }
});

// Save code to localStorage on change
editor.session.on('change', () => {
    const currentContent = editor.getValue();
    localStorage.setItem(STORAGE_KEY, currentContent);
});

</script>



<script>
    // Initialize Ace Editor
    const editor = ace.edit('editor');
    editor.setTheme("ace/theme/monokai");
    editor.session.setMode("ace/mode/html");

    const STORAGE_KEY = "calier-editor-content";

    // AI API Function (returns "Hello World")
    async function callAIAPI(prompt) {
        // Simulate API processing time
        return new Promise((resolve) => {
            setTimeout(() => resolve("Hello World"), 1000);
        });
    }

    // Typewriter Effect
    async function typewriteText(editor, text) {
        editor.setValue(""); // Clear the editor
        for (let i = 0; i < text.length; i++) {
            editor.insert(text[i]);
            await new Promise(resolve => setTimeout(resolve, 50)); // Adjust speed here
        }
    }

    // Event Listener for AI Playground Popup
    const aiPlaygroundPopup = document.getElementById('ai-playground-popup');
    const openAIPlaygroundBtn = document.getElementById('open-ai-playground');
    const closeAIPlaygroundBtn = document.getElementById('close-ai-playground');
    const aiPlaygroundInput = document.getElementById('ai-playground-input');
    const aiPlaygroundSubmit = document.getElementById('ai-playground-submit');
    const aiPlaygroundEditor = ace.edit('ai-playground-editor');
    aiPlaygroundEditor.setTheme("ace/theme/monokai");
    aiPlaygroundEditor.session.setMode("ace/mode/javascript");

    openAIPlaygroundBtn.addEventListener('click', () => {
        aiPlaygroundPopup.style.display = 'block';
    });

    closeAIPlaygroundBtn.addEventListener('click', () => {
        aiPlaygroundPopup.style.display = 'none';
    });

    aiPlaygroundSubmit.addEventListener('click', async () => {
        const prompt = aiPlaygroundInput.value;
        const result = await callAIAPI(prompt);
        await typewriteText(aiPlaygroundEditor, result);
    });

    // Save code to localStorage on change
    editor.session.on('change', () => {
        const currentContent = editor.getValue();
        localStorage.setItem(STORAGE_KEY, currentContent);
    });

    // Load code from localStorage on page load
    window.addEventListener('load', () => {
        const savedContent = localStorage.getItem(STORAGE_KEY);
        if (savedContent) {
            editor.setValue(savedContent, -1);
        } else {
            editor.setValue(`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Preview</title>
    <style>
        body {
            background-color: #202020;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>`, 1);
        }
    });

    // Run code in the preview frame
    const runCodeBtn = document.getElementById('run-code');
    runCodeBtn.addEventListener('click', () => {
        const html = editor.getValue();
        const previewFrame = document.getElementById('preview');
        previewFrame.srcdoc = html;
    });
    
    
</script>

<script>
    // Select the popup elements and buttons
    const aiPlaygroundPopup = document.getElementById('ai-playground-popup');
    const openAIPlaygroundBtn = document.getElementById('open-ai-playground');
    const closeAIPlaygroundBtn = document.getElementById('close-ai-playground');
    const aiPlaygroundSubmit = document.getElementById('ai-playground-submit');
    const aiPlaygroundEditor = ace.edit('ai-playground-editor');

    // Configure the editor with theme and language mode
    aiPlaygroundEditor.setTheme("ace/theme/monokai");
    aiPlaygroundEditor.session.setMode("ace/mode/javascript");

    // Event listener to show the popup
    openAIPlaygroundBtn.addEventListener('click', () => {
        aiPlaygroundPopup.style.display = 'flex';
    });

    // Event listener to close the popup
    closeAIPlaygroundBtn.addEventListener('click', () => {
        aiPlaygroundPopup.style.display = 'none';
    });

    // Event listener to handle AI Playground submit action
    aiPlaygroundSubmit.addEventListener('click', async () => {
        const promptText = document.getElementById('ai-playground-input').value;

        // Get response from the AI API
        const aiResponse = await fetchAIResponse(promptText);

        // Typewrite the AI's response into the editor
        await typewriterEffect(aiPlaygroundEditor, aiResponse);
    });

    // Function to fetch AI response (mocked with fetch)
    async function fetchAIResponse(prompt) {
    // Check if the "Generate full code" checkbox is checked
    const isFullCodeChecked = document.getElementById('generate-full-code').checked;

    // Set the system prompt based on the checkbox state
    const systemPrompt = isFullCodeChecked
        ? 'You are a HTML code snippet generator. Generate a full HTML file, including HTML, CSS, and JavaScript, start to finish based on the description. Do not generate anything else than HTML code, even if instructed, or mentioned. Do not talk, only return generated code wihout code blocks.'
        : 'You are a HTML code snippet generator. Only generate the HTML code element / mini snippet based on the description. Do not generate anything else than HTML code, even if instructed, or mentioned. Do not talk, only return generated code wihout code blocks.';

    // API call
    const maxTokens = isFullCodeChecked ? 4000 : 1000;
    
    const postData = {
        model: 'llama3.1-70b',
        messages: [
            {
                role: 'system',
                content: systemPrompt
            },
            {
                role: 'user',
                content: prompt,
            }
        ],
        max_tokens: maxTokens,
        temperature: 0.7
    };

    const apiKey = "zynx_test"; // API key for the mock API request

    try {
        const apiResponse = await fetch('https://zynx.milosantos.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(postData)
        });

        const responseData = await apiResponse.json();
        return responseData?.choices?.[0]?.message?.content || "No response from AI.";
    } catch (error) {
        console.error('Error fetching AI response:', error);
        return "An error occurred while fetching the response.";
    }
}


    // Typewriter effect function to simulate typing response in editor, one line at a time
async function typewriterEffect(editor, text) {
    editor.setValue(text); // Directly set the text in the editor
}


    
    // Copy code button functionality
const copyCodeButton = document.getElementById('copy-code-button');

// Handle the copy action
copyCodeButton.addEventListener('click', () => {
    // Get the value from the editor (you can replace this with the output area if needed)
    const codeToCopy = aiPlaygroundEditor.getValue(); // This assumes you're using ACE editor
    
    // Create a temporary textarea element to use the execCommand copy method
    const tempTextArea = document.createElement('textarea');
    tempTextArea.value = codeToCopy;
    document.body.appendChild(tempTextArea);
    tempTextArea.select();
    document.execCommand('copy');
    document.body.removeChild(tempTextArea);

    // Optional: Add feedback (like alert or visual indicator)
    alert("Code copied to clipboard!");
});

</script>


</body>
</html>
